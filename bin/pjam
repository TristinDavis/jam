#!/usr/bin/env ruby

require "rubygems"; 
require 'trollop'
require "json"; 
require 'term/ansicolor'
include Term::ANSIColor

opts = Trollop::options do

  version "pjam 0.0.1 (c) 2013 Alexey Melezhik / melezhik@gmail.com"
  banner <<-EOS
smart glue between pinto and your scm.

Usage:
       pjam [options]
where [options] are:
EOS

    opt :p, "path to project", :type => :string
    opt :skip_pinto, "skipp adding distos to pinto", :default => false
    opt :only, "only build this projects", :type => :string, :default => nil
end


project_id = "#{Dir.pwd}/#{opts[:p]}"
local_lib = "#{project_id}/cpanlib"

if (opts[:p].nil? || opts[:p].empty?)
    Trollop::die :p, "must be set"
end


config = JSON.parse(File.read("#{project_id}/pjam.json"))


sources_list = []
if opts[:only].nil?
    sources_list = config['sources']
else
    p_only = opts[:only].split(/\s+/)
    sources_list = config['sources'].select {|i| p_only.include? i }
end

compile_list = []
compile_list_pp = {}

sources_list.each do |src|

    cmd = "cd #{project_id}/#{src} && rm -rf cpanlib && svn up -q"
    st = system(cmd) == true or  raise "failed do cmd: #{cmd}" 

    cmd = "cd #{project_id}/#{src} && rm -rf *.gz && rm -rf MANIFEST && perl Build.PL --quiet 1>/dev/null 2>module_build.err.log  && ./Build realclean && perl Build.PL --quiet 1>/dev/null 2>module_build.err.log && ./Build manifest --quiet 2>/dev/null 1>/dev/null  && ./Build dist --quiet 1>/dev/null"
    system(cmd) == true or raise "failed do cmd: #{cmd}"

    distro_name = `cd #{project_id}/#{src} &&  ls *.gz`.chomp!

    if opts[:skip_pinto] == true

        compile_list << distro_name
	compile_list_pp[distro_name] = src

    else

        puts dark { magenta  { bold {  "add #{src} [#{distro_name}] to pinto" } } }    
    
	cmd ="cd #{project_id}/#{src} && pinto delete -v PINTO/#{distro_name}"
        system(cmd) == true

	cmd ="cd #{project_id}/#{src} && pinto add -x AdriverCore::AdRiverCookie -s #{config['stack']} -v #{distro_name}"
        system(cmd) == true or raise "failed do cmd: #{cmd}"

        compile_list << distro_name
        compile_list_pp[distro_name] = src

    end
    
end


compile_list.each do |d|
    puts green { bold { "compile #{compile_list_pp[d]} [#{d}]" } }
    cmd = "pinto install -s #{config['stack']} -l #{local_lib} -o 'q' PINTO/#{d}"
    system(cmd) == true or raise "failed do cmd: #{cmd}"
end


if config.has_key? 'modules'
    puts dark { blue  { bold {  "pulling / compiling misc modules" } } }
    config['modules'].each do |m|

	puts dark { magenta { bold {  "pull #{m}" } } }
	cmd ="pinto pull -s #{config['stack']} -v #{m}"
        system(cmd) == true or raise "failed do cmd: #{cmd}"
        
	puts dark { green { bold { "compile #{m}" } } }
	cmd = "pinto install -s #{config['stack']} -l #{local_lib} -o 'q' #{m}"
	system(cmd) == true or raise "failed do cmd: #{cmd}"
        
    end
end

puts yellow { bold {  "make distributive from #{config['application']}" } }
cmd = "cd #{project_id}/#{config['application']} && rm -rf cpanlib && mkdir cpanlib/ && cp -r #{local_lib}/* cpanlib/ && rm -rf *.gz && ./Build realclean --quiet 1>/dev/null && perl Build.PL --quiet 1>/dev/null 2>module_build.err.log && ./Build manifest --quiet 2>/dev/null 1>/dev/null && ./Build dist --quiet 1>/dev/null && ln -fs `ls #{project_id}/#{config['application']}/*.gz` #{project_id}/current.tar.gz && echo -n `ls *.gz` > #{project_id}/current.txt"
system(cmd) == true or raise "failed do cmd: #{cmd}"


